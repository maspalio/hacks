#!/usr/bin/env perl

#
# Bitch.
#

use Modern::Perl;

#
# Dependencies.
#

use DateTime;
use DateTime::Format::Epoch;

use JSON::XS;
use YAML::XS qw( Dump );

#
# Core.
#

my $days = 28;

my @commits = day_wise_commits ( $days );

#say STDERR $_->{ymd} . " : " . sprintf ( '%02d', $_->{count} ) . " -- " . $_->{dow} for reverse @commits;

print + JSON::XS->new->pretty(1)->encode ( \@commits );

#
# Subs.
#

sub day_wise_commits {
  my ( $days ) = @_;
  
  my $days_less_one = $days - 1;

  my $disco     = DateTime->new ( year => 1970, month => 1, day => 1 );
  my $formatter = DateTime::Format::Epoch->new ( epoch => $disco );

  open my $fh, qq{ git log --since="$days_less_one days ago" --until="now" --format="%h,%aN,%ct,%s" | } or die;

  my $h;

  while ( <$fh> ) {
    chomp;

    my ( $hash, $author, $epoch, $message ) = split ',', $_;

    my $dt = $formatter->parse_datetime ( $epoch );

    push @{$h->{$dt->ymd}->{commits}}, {
      hash    => $hash,
      author  => $author,
      message => $message,
      epoch   => $epoch,
      iso8601 => $dt->iso8601,
    };
  }

  fill_in ( $days => $h );

  return map { {
    ymd     => $_, 
    dow     => $h->{$_}->{dow},
    count   => $h->{$_}->{commits} ? scalar @{$h->{$_}->{commits}} : 0,
   #commits => $h->{$_}->{commits},
  } } sort keys %$h;
}

sub fill_in {
  my ( $days, $h ) = @_;

  my $dt = DateTime->now;
  
  for ( 1 .. $days ) {
    $h->{$dt->ymd}->{dow} = $dt->day_name;

    $dt->add ( days => -1 );
  }

  return $h;
}